{"ast":null,"code":"import { Contract, SorobanRpc, TransactionBuilder, BASE_FEE, Address, nativeToScVal } from '@stellar/stellar-sdk';\nimport { CONTRACT_CONFIG, getCurrentNetworkConfig } from '../config/contracts';\nexport class ContractService {\n  constructor() {\n    this.contract = void 0;\n    this.server = void 0;\n    this.networkConfig = getCurrentNetworkConfig();\n    this.server = new SorobanRpc.Server(this.networkConfig.sorobanRpcUrl);\n    this.contract = new Contract(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID);\n  }\n\n  /**\r\n   * Create a new token on the launchpad\r\n   */\n  async createToken(params, creatorPublicKey) {\n    try {\n      // For now, simulate token creation since the contract methods may not be fully implemented\n      console.log('Token creation params:', params);\n      console.log('Creator:', creatorPublicKey);\n\n      // Simulate a successful transaction XDR\n      // In a real implementation, this would call the actual contract method\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay\n\n      // Return a mock transaction XDR for now\n      return 'mock_transaction_xdr_' + Date.now();\n    } catch (error) {\n      console.error('Error creating token:', error);\n      throw new Error(`Failed to create token: ${error}`);\n    }\n  }\n\n  /**\r\n   * Buy tokens from the bonding curve\r\n   */\n  async buyTokens(tokenAddress, xlmAmount, buyerPublicKey) {\n    try {\n      const account = await this.server.getAccount(buyerPublicKey);\n      const transaction = new TransactionBuilder(account, {\n        fee: BASE_FEE,\n        networkPassphrase: this.networkConfig.networkPassphrase\n      }).addOperation(this.contract.call(CONTRACT_CONFIG.METHODS.BUY_TOKENS, new Address(tokenAddress).toScVal(), nativeToScVal(xlmAmount * 10000000, {\n        type: 'i128'\n      }),\n      // Convert to stroops\n      new Address(buyerPublicKey).toScVal())).setTimeout(30).build();\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\n      return preparedTransaction.toXDR();\n    } catch (error) {\n      console.error('Error buying tokens:', error);\n      throw new Error(`Failed to buy tokens: ${error}`);\n    }\n  }\n\n  /**\r\n   * Sell tokens back to the bonding curve\r\n   */\n  async sellTokens(tokenAddress, tokenAmount, sellerPublicKey) {\n    try {\n      const account = await this.server.getAccount(sellerPublicKey);\n      const transaction = new TransactionBuilder(account, {\n        fee: BASE_FEE,\n        networkPassphrase: this.networkConfig.networkPassphrase\n      }).addOperation(this.contract.call(CONTRACT_CONFIG.METHODS.SELL_TOKENS, new Address(tokenAddress).toScVal(), nativeToScVal(tokenAmount * 10000000, {\n        type: 'i128'\n      }),\n      // Convert to smallest unit\n      new Address(sellerPublicKey).toScVal())).setTimeout(30).build();\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\n      return preparedTransaction.toXDR();\n    } catch (error) {\n      console.error('Error selling tokens:', error);\n      throw new Error(`Failed to sell tokens: ${error}`);\n    }\n  }\n\n  /**\r\n   * Get token information\r\n   */\n  async getTokenInfo(tokenAddress) {\n    try {\n      // For demo purposes, return mock data since the contract methods may not be implemented yet\n      console.log('Getting token info for:', tokenAddress);\n\n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Return mock token data\n      return {\n        name: 'Demo Token',\n        symbol: 'DEMO',\n        totalSupply: 1000000,\n        creator: 'GC4H63C77AZ4URQKZ7FPWI2JRP4JVRM6OQ2QVNNTU5CO3GF7SAAMQ5L2',\n        tokenAddress: tokenAddress,\n        currentPrice: 0.0001,\n        totalRaised: 1250.5,\n        isGraduated: false\n      };\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Get bonding curve information\r\n   */\n  async getBondingCurveInfo(tokenAddress) {\n    try {\n      // For demo purposes, return mock data\n      console.log('Getting bonding curve info for:', tokenAddress);\n\n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Return mock bonding curve data\n      return {\n        currentPrice: 0.0001,\n        totalSupply: 1000000,\n        reserveBalance: 1250.5,\n        tokensInCurve: 875000,\n        graduationThreshold: CONTRACT_CONFIG.PLATFORM.GRADUATION_THRESHOLD\n      };\n    } catch (error) {\n      console.error('Error getting bonding curve info:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Calculate tokens received for XLM amount\r\n   */\n  calculateTokensForXLM(xlmAmount, currentPrice) {\n    // Simple linear bonding curve calculation\n    // In production, this should match the contract's calculation exactly\n    return xlmAmount / currentPrice;\n  }\n\n  /**\r\n   * Calculate XLM received for token amount\r\n   */\n  calculateXLMForTokens(tokenAmount, currentPrice) {\n    // Simple linear bonding curve calculation\n    // In production, this should match the contract's calculation exactly\n    return tokenAmount * currentPrice * 0.99; // 1% slippage\n  }\n}\n\n// Export singleton instance\nexport const contractService = new ContractService();","map":{"version":3,"names":["Contract","SorobanRpc","TransactionBuilder","BASE_FEE","Address","nativeToScVal","CONTRACT_CONFIG","getCurrentNetworkConfig","ContractService","constructor","contract","server","networkConfig","Server","sorobanRpcUrl","LAUNCHPAD_CONTRACT_ID","createToken","params","creatorPublicKey","console","log","Promise","resolve","setTimeout","Date","now","error","Error","buyTokens","tokenAddress","xlmAmount","buyerPublicKey","account","getAccount","transaction","fee","networkPassphrase","addOperation","call","METHODS","BUY_TOKENS","toScVal","type","build","preparedTransaction","prepareTransaction","toXDR","sellTokens","tokenAmount","sellerPublicKey","SELL_TOKENS","getTokenInfo","name","symbol","totalSupply","creator","currentPrice","totalRaised","isGraduated","getBondingCurveInfo","reserveBalance","tokensInCurve","graduationThreshold","PLATFORM","GRADUATION_THRESHOLD","calculateTokensForXLM","calculateXLMForTokens","contractService"],"sources":["C:/Users/Debojyoti DM/Desktop/assetlifecyclesdk/frontend/src/services/ContractService.ts"],"sourcesContent":["import {\r\n  Contract,\r\n  SorobanRpc,\r\n  TransactionBuilder,\r\n  Networks,\r\n  BASE_FEE,\r\n  xdr,\r\n  Address,\r\n  nativeToScVal,\r\n  scValToNative,\r\n} from '@stellar/stellar-sdk';\r\nimport { CONTRACT_CONFIG, getCurrentNetworkConfig } from '../config/contracts';\r\n\r\nexport interface TokenCreationParams {\r\n  name: string;\r\n  symbol: string;\r\n  totalSupply: number;\r\n  description?: string;\r\n  launchThresholdXlm?: number;\r\n  launchThresholdPercent?: number;\r\n}\r\n\r\nexport interface TokenInfo {\r\n  name: string;\r\n  symbol: string;\r\n  totalSupply: number;\r\n  tokensSold: number;\r\n  xlmRaised: number;\r\n  currentPrice: number;\r\n  launchProgressPercent: number;\r\n  isLaunched: boolean;\r\n  creator: string;\r\n  creationTime: number;\r\n}\r\n\r\nexport interface BondingCurveInfo {\r\n  currentPrice: number;\r\n  totalSupply: number;\r\n  reserveBalance: number;\r\n  tokensInCurve: number;\r\n  graduationThreshold: number;\r\n}\r\n\r\nexport class ContractService {\r\n  private contract: Contract;\r\n  private server: SorobanRpc.Server;\r\n  private networkConfig = getCurrentNetworkConfig();\r\n\r\n  constructor() {\r\n    this.server = new SorobanRpc.Server(this.networkConfig.sorobanRpcUrl);\r\n    this.contract = new Contract(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID);\r\n  }\r\n\r\n  /**\r\n   * Create a new token on the launchpad\r\n   */\r\n  async createToken(\r\n    params: TokenCreationParams,\r\n    creatorPublicKey: string\r\n  ): Promise<string> {\r\n    try {\r\n      // For now, simulate token creation since the contract methods may not be fully implemented\r\n      console.log('Token creation params:', params);\r\n      console.log('Creator:', creatorPublicKey);\r\n      \r\n      // Simulate a successful transaction XDR\r\n      // In a real implementation, this would call the actual contract method\r\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay\r\n      \r\n      // Return a mock transaction XDR for now\r\n      return 'mock_transaction_xdr_' + Date.now();\r\n    } catch (error) {\r\n      console.error('Error creating token:', error);\r\n      throw new Error(`Failed to create token: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Buy tokens from the bonding curve\r\n   */\r\n  async buyTokens(\r\n    tokenAddress: string,\r\n    xlmAmount: number,\r\n    buyerPublicKey: string\r\n  ): Promise<string> {\r\n    try {\r\n      const account = await this.server.getAccount(buyerPublicKey);\r\n      \r\n      const transaction = new TransactionBuilder(account, {\r\n        fee: BASE_FEE,\r\n        networkPassphrase: this.networkConfig.networkPassphrase,\r\n      })\r\n        .addOperation(\r\n          this.contract.call(\r\n            CONTRACT_CONFIG.METHODS.BUY_TOKENS,\r\n            new Address(tokenAddress).toScVal(),\r\n            nativeToScVal(xlmAmount * 10000000, { type: 'i128' }), // Convert to stroops\r\n            new Address(buyerPublicKey).toScVal()\r\n          )\r\n        )\r\n        .setTimeout(30)\r\n        .build();\r\n\r\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\r\n      return preparedTransaction.toXDR();\r\n    } catch (error) {\r\n      console.error('Error buying tokens:', error);\r\n      throw new Error(`Failed to buy tokens: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sell tokens back to the bonding curve\r\n   */\r\n  async sellTokens(\r\n    tokenAddress: string,\r\n    tokenAmount: number,\r\n    sellerPublicKey: string\r\n  ): Promise<string> {\r\n    try {\r\n      const account = await this.server.getAccount(sellerPublicKey);\r\n      \r\n      const transaction = new TransactionBuilder(account, {\r\n        fee: BASE_FEE,\r\n        networkPassphrase: this.networkConfig.networkPassphrase,\r\n      })\r\n        .addOperation(\r\n          this.contract.call(\r\n            CONTRACT_CONFIG.METHODS.SELL_TOKENS,\r\n            new Address(tokenAddress).toScVal(),\r\n            nativeToScVal(tokenAmount * 10000000, { type: 'i128' }), // Convert to smallest unit\r\n            new Address(sellerPublicKey).toScVal()\r\n          )\r\n        )\r\n        .setTimeout(30)\r\n        .build();\r\n\r\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\r\n      return preparedTransaction.toXDR();\r\n    } catch (error) {\r\n      console.error('Error selling tokens:', error);\r\n      throw new Error(`Failed to sell tokens: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get token information\r\n   */\r\n  async getTokenInfo(tokenAddress: string): Promise<TokenInfo | null> {\r\n    try {\r\n      // For demo purposes, return mock data since the contract methods may not be implemented yet\r\n      console.log('Getting token info for:', tokenAddress);\r\n      \r\n      // Simulate network delay\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n      \r\n      // Return mock token data\r\n      return {\r\n        name: 'Demo Token',\r\n        symbol: 'DEMO',\r\n        totalSupply: 1000000,\r\n        creator: 'GC4H63C77AZ4URQKZ7FPWI2JRP4JVRM6OQ2QVNNTU5CO3GF7SAAMQ5L2',\r\n        tokenAddress: tokenAddress,\r\n        currentPrice: 0.0001,\r\n        totalRaised: 1250.5,\r\n        isGraduated: false,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting token info:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get bonding curve information\r\n   */\r\n  async getBondingCurveInfo(tokenAddress: string): Promise<BondingCurveInfo | null> {\r\n    try {\r\n      // For demo purposes, return mock data\r\n      console.log('Getting bonding curve info for:', tokenAddress);\r\n      \r\n      // Simulate network delay\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n      \r\n      // Return mock bonding curve data\r\n      return {\r\n        currentPrice: 0.0001,\r\n        totalSupply: 1000000,\r\n        reserveBalance: 1250.5,\r\n        tokensInCurve: 875000,\r\n        graduationThreshold: CONTRACT_CONFIG.PLATFORM.GRADUATION_THRESHOLD,\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting bonding curve info:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate tokens received for XLM amount\r\n   */\r\n  calculateTokensForXLM(xlmAmount: number, currentPrice: number): number {\r\n    // Simple linear bonding curve calculation\r\n    // In production, this should match the contract's calculation exactly\r\n    return xlmAmount / currentPrice;\r\n  }\r\n\r\n  /**\r\n   * Calculate XLM received for token amount\r\n   */\r\n  calculateXLMForTokens(tokenAmount: number, currentPrice: number): number {\r\n    // Simple linear bonding curve calculation\r\n    // In production, this should match the contract's calculation exactly\r\n    return tokenAmount * currentPrice * 0.99; // 1% slippage\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const contractService = new ContractService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}