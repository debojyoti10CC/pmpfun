{"ast":null,"code":"import { Contract, SorobanRpc, TransactionBuilder, BASE_FEE, Address, nativeToScVal, scValToNative } from '@stellar/stellar-sdk';\nimport { CONTRACT_CONFIG, getCurrentNetworkConfig } from '../config/contracts';\nexport class ContractService {\n  constructor() {\n    this.contract = void 0;\n    this.server = void 0;\n    this.networkConfig = getCurrentNetworkConfig();\n    this.server = new SorobanRpc.Server(this.networkConfig.sorobanRpcUrl);\n    this.contract = new Contract(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID);\n  }\n\n  /**\r\n   * Create a new token on the launchpad\r\n   */\n  async createToken(params, creatorPublicKey) {\n    try {\n      // For now, simulate token creation since the contract methods may not be fully implemented\n      console.log('Token creation params:', params);\n      console.log('Creator:', creatorPublicKey);\n\n      // Simulate a successful transaction XDR\n      // In a real implementation, this would call the actual contract method\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay\n\n      // Return a mock transaction XDR for now\n      return 'mock_transaction_xdr_' + Date.now();\n    } catch (error) {\n      console.error('Error creating token:', error);\n      throw new Error(`Failed to create token: ${error}`);\n    }\n  }\n\n  /**\r\n   * Buy tokens from the bonding curve\r\n   */\n  async buyTokens(tokenAddress, xlmAmount, buyerPublicKey) {\n    try {\n      const account = await this.server.getAccount(buyerPublicKey);\n      const transaction = new TransactionBuilder(account, {\n        fee: BASE_FEE,\n        networkPassphrase: this.networkConfig.networkPassphrase\n      }).addOperation(this.contract.call(CONTRACT_CONFIG.METHODS.BUY_TOKENS, new Address(tokenAddress).toScVal(), nativeToScVal(xlmAmount * 10000000, {\n        type: 'i128'\n      }),\n      // Convert to stroops\n      new Address(buyerPublicKey).toScVal())).setTimeout(30).build();\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\n      return preparedTransaction.toXDR();\n    } catch (error) {\n      console.error('Error buying tokens:', error);\n      throw new Error(`Failed to buy tokens: ${error}`);\n    }\n  }\n\n  /**\r\n   * Sell tokens back to the bonding curve\r\n   */\n  async sellTokens(tokenAddress, tokenAmount, sellerPublicKey) {\n    try {\n      const account = await this.server.getAccount(sellerPublicKey);\n      const transaction = new TransactionBuilder(account, {\n        fee: BASE_FEE,\n        networkPassphrase: this.networkConfig.networkPassphrase\n      }).addOperation(this.contract.call(CONTRACT_CONFIG.METHODS.SELL_TOKENS, new Address(tokenAddress).toScVal(), nativeToScVal(tokenAmount * 10000000, {\n        type: 'i128'\n      }),\n      // Convert to smallest unit\n      new Address(sellerPublicKey).toScVal())).setTimeout(30).build();\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\n      return preparedTransaction.toXDR();\n    } catch (error) {\n      console.error('Error selling tokens:', error);\n      throw new Error(`Failed to sell tokens: ${error}`);\n    }\n  }\n\n  /**\r\n   * Get token information\r\n   */\n  async getTokenInfo(tokenAddress) {\n    try {\n      var _result$result;\n      const transaction = new TransactionBuilder(await this.server.getAccount(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID), {\n        fee: BASE_FEE,\n        networkPassphrase: this.networkConfig.networkPassphrase\n      }).addOperation(this.contract.call(CONTRACT_CONFIG.METHODS.GET_TOKEN_INFO, new Address(tokenAddress).toScVal())).setTimeout(30).build();\n      const result = await this.server.simulateTransaction(transaction);\n      if ('error' in result) {\n        console.error('Simulation error:', result.error);\n        return null;\n      }\n      if ('result' in result && (_result$result = result.result) !== null && _result$result !== void 0 && _result$result.retval) {\n        const tokenData = scValToNative(result.result.retval);\n        return {\n          name: tokenData.name,\n          symbol: tokenData.symbol,\n          totalSupply: tokenData.total_supply,\n          creator: tokenData.creator,\n          tokenAddress: tokenAddress,\n          currentPrice: tokenData.current_price / 10000000,\n          // Convert from stroops\n          totalRaised: tokenData.total_raised / 10000000,\n          isGraduated: tokenData.is_graduated\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error getting token info:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Get bonding curve information\r\n   */\n  async getBondingCurveInfo(tokenAddress) {\n    try {\n      var _result$result2;\n      const transaction = new TransactionBuilder(await this.server.getAccount(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID), {\n        fee: BASE_FEE,\n        networkPassphrase: this.networkConfig.networkPassphrase\n      }).addOperation(this.contract.call(CONTRACT_CONFIG.METHODS.GET_BONDING_CURVE_INFO, new Address(tokenAddress).toScVal())).setTimeout(30).build();\n      const result = await this.server.simulateTransaction(transaction);\n      if ('error' in result) {\n        console.error('Simulation error:', result.error);\n        return null;\n      }\n      if ('result' in result && (_result$result2 = result.result) !== null && _result$result2 !== void 0 && _result$result2.retval) {\n        const curveData = scValToNative(result.result.retval);\n        return {\n          currentPrice: curveData.current_price / 10000000,\n          totalSupply: curveData.total_supply,\n          reserveBalance: curveData.reserve_balance / 10000000,\n          tokensInCurve: curveData.tokens_in_curve,\n          graduationThreshold: CONTRACT_CONFIG.PLATFORM.GRADUATION_THRESHOLD\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error getting bonding curve info:', error);\n      return null;\n    }\n  }\n\n  /**\r\n   * Calculate tokens received for XLM amount\r\n   */\n  calculateTokensForXLM(xlmAmount, currentPrice) {\n    // Simple linear bonding curve calculation\n    // In production, this should match the contract's calculation exactly\n    return xlmAmount / currentPrice;\n  }\n\n  /**\r\n   * Calculate XLM received for token amount\r\n   */\n  calculateXLMForTokens(tokenAmount, currentPrice) {\n    // Simple linear bonding curve calculation\n    // In production, this should match the contract's calculation exactly\n    return tokenAmount * currentPrice * 0.99; // 1% slippage\n  }\n}\n\n// Export singleton instance\nexport const contractService = new ContractService();","map":{"version":3,"names":["Contract","SorobanRpc","TransactionBuilder","BASE_FEE","Address","nativeToScVal","scValToNative","CONTRACT_CONFIG","getCurrentNetworkConfig","ContractService","constructor","contract","server","networkConfig","Server","sorobanRpcUrl","LAUNCHPAD_CONTRACT_ID","createToken","params","creatorPublicKey","console","log","Promise","resolve","setTimeout","Date","now","error","Error","buyTokens","tokenAddress","xlmAmount","buyerPublicKey","account","getAccount","transaction","fee","networkPassphrase","addOperation","call","METHODS","BUY_TOKENS","toScVal","type","build","preparedTransaction","prepareTransaction","toXDR","sellTokens","tokenAmount","sellerPublicKey","SELL_TOKENS","getTokenInfo","_result$result","GET_TOKEN_INFO","result","simulateTransaction","retval","tokenData","name","symbol","totalSupply","total_supply","creator","currentPrice","current_price","totalRaised","total_raised","isGraduated","is_graduated","getBondingCurveInfo","_result$result2","GET_BONDING_CURVE_INFO","curveData","reserveBalance","reserve_balance","tokensInCurve","tokens_in_curve","graduationThreshold","PLATFORM","GRADUATION_THRESHOLD","calculateTokensForXLM","calculateXLMForTokens","contractService"],"sources":["C:/Users/Debojyoti DM/Desktop/assetlifecyclesdk/frontend/src/services/ContractService.ts"],"sourcesContent":["import {\r\n  Contract,\r\n  SorobanRpc,\r\n  TransactionBuilder,\r\n  Networks,\r\n  BASE_FEE,\r\n  xdr,\r\n  Address,\r\n  nativeToScVal,\r\n  scValToNative,\r\n} from '@stellar/stellar-sdk';\r\nimport { CONTRACT_CONFIG, getCurrentNetworkConfig } from '../config/contracts';\r\n\r\nexport interface TokenCreationParams {\r\n  name: string;\r\n  symbol: string;\r\n  totalSupply: number;\r\n  description?: string;\r\n}\r\n\r\nexport interface TokenInfo {\r\n  name: string;\r\n  symbol: string;\r\n  totalSupply: number;\r\n  creator: string;\r\n  tokenAddress: string;\r\n  currentPrice: number;\r\n  totalRaised: number;\r\n  isGraduated: boolean;\r\n}\r\n\r\nexport interface BondingCurveInfo {\r\n  currentPrice: number;\r\n  totalSupply: number;\r\n  reserveBalance: number;\r\n  tokensInCurve: number;\r\n  graduationThreshold: number;\r\n}\r\n\r\nexport class ContractService {\r\n  private contract: Contract;\r\n  private server: SorobanRpc.Server;\r\n  private networkConfig = getCurrentNetworkConfig();\r\n\r\n  constructor() {\r\n    this.server = new SorobanRpc.Server(this.networkConfig.sorobanRpcUrl);\r\n    this.contract = new Contract(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID);\r\n  }\r\n\r\n  /**\r\n   * Create a new token on the launchpad\r\n   */\r\n  async createToken(\r\n    params: TokenCreationParams,\r\n    creatorPublicKey: string\r\n  ): Promise<string> {\r\n    try {\r\n      // For now, simulate token creation since the contract methods may not be fully implemented\r\n      console.log('Token creation params:', params);\r\n      console.log('Creator:', creatorPublicKey);\r\n      \r\n      // Simulate a successful transaction XDR\r\n      // In a real implementation, this would call the actual contract method\r\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay\r\n      \r\n      // Return a mock transaction XDR for now\r\n      return 'mock_transaction_xdr_' + Date.now();\r\n    } catch (error) {\r\n      console.error('Error creating token:', error);\r\n      throw new Error(`Failed to create token: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Buy tokens from the bonding curve\r\n   */\r\n  async buyTokens(\r\n    tokenAddress: string,\r\n    xlmAmount: number,\r\n    buyerPublicKey: string\r\n  ): Promise<string> {\r\n    try {\r\n      const account = await this.server.getAccount(buyerPublicKey);\r\n      \r\n      const transaction = new TransactionBuilder(account, {\r\n        fee: BASE_FEE,\r\n        networkPassphrase: this.networkConfig.networkPassphrase,\r\n      })\r\n        .addOperation(\r\n          this.contract.call(\r\n            CONTRACT_CONFIG.METHODS.BUY_TOKENS,\r\n            new Address(tokenAddress).toScVal(),\r\n            nativeToScVal(xlmAmount * 10000000, { type: 'i128' }), // Convert to stroops\r\n            new Address(buyerPublicKey).toScVal()\r\n          )\r\n        )\r\n        .setTimeout(30)\r\n        .build();\r\n\r\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\r\n      return preparedTransaction.toXDR();\r\n    } catch (error) {\r\n      console.error('Error buying tokens:', error);\r\n      throw new Error(`Failed to buy tokens: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sell tokens back to the bonding curve\r\n   */\r\n  async sellTokens(\r\n    tokenAddress: string,\r\n    tokenAmount: number,\r\n    sellerPublicKey: string\r\n  ): Promise<string> {\r\n    try {\r\n      const account = await this.server.getAccount(sellerPublicKey);\r\n      \r\n      const transaction = new TransactionBuilder(account, {\r\n        fee: BASE_FEE,\r\n        networkPassphrase: this.networkConfig.networkPassphrase,\r\n      })\r\n        .addOperation(\r\n          this.contract.call(\r\n            CONTRACT_CONFIG.METHODS.SELL_TOKENS,\r\n            new Address(tokenAddress).toScVal(),\r\n            nativeToScVal(tokenAmount * 10000000, { type: 'i128' }), // Convert to smallest unit\r\n            new Address(sellerPublicKey).toScVal()\r\n          )\r\n        )\r\n        .setTimeout(30)\r\n        .build();\r\n\r\n      const preparedTransaction = await this.server.prepareTransaction(transaction);\r\n      return preparedTransaction.toXDR();\r\n    } catch (error) {\r\n      console.error('Error selling tokens:', error);\r\n      throw new Error(`Failed to sell tokens: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get token information\r\n   */\r\n  async getTokenInfo(tokenAddress: string): Promise<TokenInfo | null> {\r\n    try {\r\n      const transaction = new TransactionBuilder(\r\n        await this.server.getAccount(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID),\r\n        {\r\n          fee: BASE_FEE,\r\n          networkPassphrase: this.networkConfig.networkPassphrase,\r\n        }\r\n      )\r\n        .addOperation(\r\n          this.contract.call(\r\n            CONTRACT_CONFIG.METHODS.GET_TOKEN_INFO,\r\n            new Address(tokenAddress).toScVal()\r\n          )\r\n        )\r\n        .setTimeout(30)\r\n        .build();\r\n\r\n      const result = await this.server.simulateTransaction(transaction);\r\n      \r\n      if ('error' in result) {\r\n        console.error('Simulation error:', result.error);\r\n        return null;\r\n      }\r\n\r\n      if ('result' in result && result.result?.retval) {\r\n        const tokenData = scValToNative(result.result.retval);\r\n        return {\r\n          name: tokenData.name,\r\n          symbol: tokenData.symbol,\r\n          totalSupply: tokenData.total_supply,\r\n          creator: tokenData.creator,\r\n          tokenAddress: tokenAddress,\r\n          currentPrice: tokenData.current_price / 10000000, // Convert from stroops\r\n          totalRaised: tokenData.total_raised / 10000000,\r\n          isGraduated: tokenData.is_graduated,\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error getting token info:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get bonding curve information\r\n   */\r\n  async getBondingCurveInfo(tokenAddress: string): Promise<BondingCurveInfo | null> {\r\n    try {\r\n      const transaction = new TransactionBuilder(\r\n        await this.server.getAccount(CONTRACT_CONFIG.LAUNCHPAD_CONTRACT_ID),\r\n        {\r\n          fee: BASE_FEE,\r\n          networkPassphrase: this.networkConfig.networkPassphrase,\r\n        }\r\n      )\r\n        .addOperation(\r\n          this.contract.call(\r\n            CONTRACT_CONFIG.METHODS.GET_BONDING_CURVE_INFO,\r\n            new Address(tokenAddress).toScVal()\r\n          )\r\n        )\r\n        .setTimeout(30)\r\n        .build();\r\n\r\n      const result = await this.server.simulateTransaction(transaction);\r\n      \r\n      if ('error' in result) {\r\n        console.error('Simulation error:', result.error);\r\n        return null;\r\n      }\r\n\r\n      if ('result' in result && result.result?.retval) {\r\n        const curveData = scValToNative(result.result.retval);\r\n        return {\r\n          currentPrice: curveData.current_price / 10000000,\r\n          totalSupply: curveData.total_supply,\r\n          reserveBalance: curveData.reserve_balance / 10000000,\r\n          tokensInCurve: curveData.tokens_in_curve,\r\n          graduationThreshold: CONTRACT_CONFIG.PLATFORM.GRADUATION_THRESHOLD,\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error getting bonding curve info:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate tokens received for XLM amount\r\n   */\r\n  calculateTokensForXLM(xlmAmount: number, currentPrice: number): number {\r\n    // Simple linear bonding curve calculation\r\n    // In production, this should match the contract's calculation exactly\r\n    return xlmAmount / currentPrice;\r\n  }\r\n\r\n  /**\r\n   * Calculate XLM received for token amount\r\n   */\r\n  calculateXLMForTokens(tokenAmount: number, currentPrice: number): number {\r\n    // Simple linear bonding curve calculation\r\n    // In production, this should match the contract's calculation exactly\r\n    return tokenAmount * currentPrice * 0.99; // 1% slippage\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const contractService = new ContractService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}